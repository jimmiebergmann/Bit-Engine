// ///////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013 Jimmie Bergmann - jimmiebergmann@gmail.com
//
// This software is provided 'as-is', without any express or
// implied warranty. In no event will the authors be held
// liable for any damages arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute
// it freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented;
//    you must not claim that you wrote the original software.
//    If you use this software in a product, an acknowledgment
//    in the product documentation would be appreciated but
//    is not required.
//
// 2. Altered source versions must be plainly marked as such,
//    and must not be misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any
//    source distribution.
// ///////////////////////////////////////////////////////////////////////////

#ifndef BIT_AUDIO_WAVE_FILE_HPP
#define BIT_AUDIO_WAVE_FILE_HPP

#include <Bit/Build.hpp>
#include <string>

namespace Bit
{

	////////////////////////////////////////////////////////////////
	/// \ingroup Audio
	/// \brief Micro$oft WAVE file class.
	/// 
	////////////////////////////////////////////////////////////////
	class BIT_API WaveFile
	{

	public:

		////////////////////////////////////////////////////////////////
		/// \brief RIFF header class.
		///
		////////////////////////////////////////////////////////////////
		class RiffHeader
		{

		public:

			// Friend class
			friend class WaveFile;

			////////////////////////////////////////////////////////////////
			/// \brief Default constructor
			/// 
			////////////////////////////////////////////////////////////////
			RiffHeader( );

			////////////////////////////////////////////////////////////////
			/// \brief Set Chunk ID, should be "RIFF"
			/// 
			////////////////////////////////////////////////////////////////
			void SetChunkId(	const Uint8 p_A, const Uint8 p_B,
								const Uint8 p_C, const Uint8 p_D );

			////////////////////////////////////////////////////////////////
			/// \brief Set chunk size.
			/// 
			////////////////////////////////////////////////////////////////
			void SetChunkSize( const Uint32 p_ChunkSize );

			////////////////////////////////////////////////////////////////
			/// \brief Set format, should be "WAVE"
			/// 
			////////////////////////////////////////////////////////////////
			void SetFormat(	const Uint8 p_A, const Uint8 p_B,
							const Uint8 p_C, const Uint8 p_D );

			////////////////////////////////////////////////////////////////
			/// \brief Get Chunk ID, should be "RIFF"
			/// 
			////////////////////////////////////////////////////////////////
			const Uint8 * GetChunkId( ) const;

			////////////////////////////////////////////////////////////////
			/// \brief Get chunk size.
			/// 
			////////////////////////////////////////////////////////////////
			Uint32 GetChunkSize( ) const;

			////////////////////////////////////////////////////////////////
			/// \brief Get format, should be "WAVE"
			/// 
			////////////////////////////////////////////////////////////////
			const Uint8 * GetFormat( ) const;

		private:

			Uint8 m_ChunkId[ 4 ];	///< Contains "RIFF" in ASCII form.
			Uint32 m_ChunkSize;		///< 4 + (8 + SubChunk1Size) + (8 + SubChunk2Size)
			Uint8 m_Format[ 4 ];	///< Contains "WAVE" in ASCII form.

		};


		////////////////////////////////////////////////////////////////
		/// \brief Fmt chunk class.
		///
		////////////////////////////////////////////////////////////////
		class FmtChunk
		{

		public:

			// Friend class
			friend class WaveFile;

			////////////////////////////////////////////////////////////////
			/// \brief Default constructor
			/// 
			////////////////////////////////////////////////////////////////
			FmtChunk( );

			////////////////////////////////////////////////////////////////
			/// \brief Set sub chunk ID. Should contain "fmt " in ASCII form.
			/// 
			////////////////////////////////////////////////////////////////
			void SetSubChunkId( const Uint8 p_A, const Uint8 p_B,
								const Uint8 p_C, const Uint8 p_D );

			////////////////////////////////////////////////////////////////
			/// \brief Set sub chunk size. 16 for PCM.
			/// 
			////////////////////////////////////////////////////////////////
			void SetSubChunkSize( const Uint32 p_SubChunkSize );

			////////////////////////////////////////////////////////////////
			/// \brief Set audio format. 1 for PCM.
			/// 
			////////////////////////////////////////////////////////////////
			void SetAudioFormat( const Uint16 p_AudioFormat );

			////////////////////////////////////////////////////////////////
			/// \brief Set number of audio channels.
			/// 
			////////////////////////////////////////////////////////////////
			void SetChannelCount( const Uint16 p_ChannelCount );

			////////////////////////////////////////////////////////////////
			/// \brief Set sample rate. 8000, 44100, etc.
			/// 
			////////////////////////////////////////////////////////////////
			void SetSampleRate( const Uint32 p_SampleRate );

			////////////////////////////////////////////////////////////////
			/// \brief Set byte rate.  SampleRate * NumChannels * BitsPerSample/8.
			/// 
			////////////////////////////////////////////////////////////////
			void SetByteRate( const Uint32 p_ByteRate );

			////////////////////////////////////////////////////////////////
			/// \brief Set block align.  NumChannels * BitsPerSample/8.
			/// 
			////////////////////////////////////////////////////////////////
			void SetBlockAlign( const Uint16 p_BlockAlign );

			////////////////////////////////////////////////////////////////
			/// \brief Set bits per sample.  8, 16, etc.
			/// 
			////////////////////////////////////////////////////////////////
			void SetBitsPerSample( const Uint16 p_BitsPerSample );

			////////////////////////////////////////////////////////////////
			/// \brief Get sub chunk ID. Should contain "fmt " in ASCII form.
			/// 
			////////////////////////////////////////////////////////////////
			const Uint8 * GetSubChunkId( ) const;

			////////////////////////////////////////////////////////////////
			/// \brief Get sub chunk size. 16 for PCM.
			/// 
			////////////////////////////////////////////////////////////////
			Uint32 GetSubChunkSize( ) const;

			////////////////////////////////////////////////////////////////
			/// \brief Get audio format. 1 for PCM.
			/// 
			////////////////////////////////////////////////////////////////
			Uint16 GetAudioFormat( ) const;

			////////////////////////////////////////////////////////////////
			/// \brief Get number of audio channels.
			/// 
			////////////////////////////////////////////////////////////////
			Uint16 GetChannelCount( ) const;

			////////////////////////////////////////////////////////////////
			/// \brief Get sample rate. 8000, 44100, etc.
			/// 
			////////////////////////////////////////////////////////////////
			Uint32 GetSampleRate( ) const;

			////////////////////////////////////////////////////////////////
			/// \brief Get byte rate.  SampleRate * NumChannels * BitsPerSample/8.
			/// 
			////////////////////////////////////////////////////////////////
			Uint32 GetByteRate( ) const;

			////////////////////////////////////////////////////////////////
			/// \brief Get block align.  NumChannels * BitsPerSample/8.
			/// 
			////////////////////////////////////////////////////////////////
			Uint16 GetBlockAlign( ) const;

			////////////////////////////////////////////////////////////////
			/// \brief Get bits per sample.  8, 16, etc.
			/// 
			////////////////////////////////////////////////////////////////
			Uint16 GetBitsPerSample( ) const;

		private:

			Uint8 m_SubChunkId[ 4 ];	///< Contains "fmt " in ASCII form.
			Uint32 m_SubChunkSize;		///< 16 for PCM.
			Uint16 m_AudioFormat;		///< 1 for PCM.
			Uint16 m_ChannelCount;		///< Number of audio channels.
			Uint32 m_SampleRate;		///< 8000, 44100, etc.
			Uint32 m_ByteRate;			///< SampleRate * NumChannels * BitsPerSample/8.
			Uint16 m_BlockAlign;		///< NumChannels * BitsPerSample/8.
			Uint16 m_BitsPerSample;		///< Bits per sample, 8, 16, etc.

		};


		////////////////////////////////////////////////////////////////
		/// \brief Data chunk class.
		///
		////////////////////////////////////////////////////////////////
		class DataChunk
		{

		public:

			// Friend class
			friend class WaveFile;

			////////////////////////////////////////////////////////////////
			/// \brief Default constructor
			///
			/// \param p_DeallocateFlag Does not deallocate the audio data
			/// at destruction if false. This is useful if you want to
			/// take over the audio data pointer from the wave file class.
			///
			////////////////////////////////////////////////////////////////
			DataChunk( const Bool p_DeallocateFlag = true );

			////////////////////////////////////////////////////////////////
			/// \brief Destructor
			///
			////////////////////////////////////////////////////////////////
			~DataChunk( );

			////////////////////////////////////////////////////////////////
			/// \brief Clear the allocated data.
			/// 
			////////////////////////////////////////////////////////////////
			void Clear( );

			////////////////////////////////////////////////////////////////
			/// \brief Set the sub chunk id, should be "data"
			/// 
			////////////////////////////////////////////////////////////////
			void SetSubChunkId( const Uint8 p_A, const Uint8 p_B,
								const Uint8 p_C, const Uint8 p_D );

			////////////////////////////////////////////////////////////////
			/// \brief Set the sub chunk size,
			///		should be NumSamples * NumChannels * BitsPerSample/8
			/// 
			////////////////////////////////////////////////////////////////
			void SetSubChunkSize( const Uint32 p_SubChunkSize );

			////////////////////////////////////////////////////////////////
			/// \brief Set the raw audio data.
			/// 
			////////////////////////////////////////////////////////////////
			void SetData( const Uint8 * p_pData, const SizeType p_DataSize );

			////////////////////////////////////////////////////////////////
			/// \brief Get the sub chunk id, should be "data"
			/// 
			////////////////////////////////////////////////////////////////
			const Uint8 * GetSubChunkId( ) const;

			////////////////////////////////////////////////////////////////
			/// \brief Get the sub chunk size,
			///		should be NumSamples * NumChannels * BitsPerSample/8
			/// 
			////////////////////////////////////////////////////////////////
			Uint32 GetSubChunkSize( ) const;

			////////////////////////////////////////////////////////////////
			/// \brief Get the raw audio data.
			/// 
			////////////////////////////////////////////////////////////////
			const Uint8 * GetData( ) const;

		private:

			// Private varaibles
			Uint8 m_SubChunkId[ 4 ];	///< Contains "data" in ASCII form.
			Uint32 m_SubChunkSize;		///< NumSamples * NumChannels * BitsPerSample/8
			Uint8 * m_pData;			///< Raw audio data.
			
			// Private varaibles, but not associated with the file format.
			Bool m_DeallocateFlag;		///< Data deallocation at destruction flag, true by default.

		};


		////////////////////////////////////////////////////////////////
		/// \brief Constructor
		/// 
		/// \param p_DeallocateFlag Does not deallocate the audio data
		/// at destruction if false. This is useful if you want to
		/// take over the audio data pointer from the wave file class.
		///
		////////////////////////////////////////////////////////////////
		WaveFile( const Bool p_DeallocateFlag = true );

		////////////////////////////////////////////////////////////////
		/// \brief Destructor
		/// 
		////////////////////////////////////////////////////////////////
		~WaveFile( );

		////////////////////////////////////////////////////////////////
		/// \brief Load WAVE file from memory.
		///
		/// \param p_pMemory Reference to the memory.
		///
		/// \return True if succeeded, else false.
		///
		////////////////////////////////////////////////////////////////
		Bool LoadFromMemory( const std::string & p_Memory );

		////////////////////////////////////////////////////////////////
		/// \brief Load WAVE file from stream.
		///
		/// \return True if succeeded, else false.
		///
		////////////////////////////////////////////////////////////////
		Bool LoadFromStream( std::istream & p_Stream );

		////////////////////////////////////////////////////////////////
		/// \brief Load WAVE file from file.
		///
		/// \param p_Filename Output file.
		///
		/// \return True if succeeded, else false.
		///
		////////////////////////////////////////////////////////////////
		Bool LoadFromFile( const std::string & p_Filename );

		////////////////////////////////////////////////////////////////
		/// \brief Save WAVE - PCM to memory.
		///
		/// \param p_pMemory Reference to the memory.
		/// \param p_Validate, If true, makes sure to save a valid WAVE file.
		///		Setting default values for invalid data in the WAVE structure.
		///
		/// \return True if succeeded, else false.
		///
		////////////////////////////////////////////////////////////////
		Bool SaveToMemory( std::string & p_Memory, const Bool p_Validate = true );

		////////////////////////////////////////////////////////////////
		/// \brief Save WAVE - PCM to stream.
		///
		/// \param p_Stream Output stream.
		/// \param p_Validate, If true, makes sure to save a valid WAVE file.
		///		Setting default values for invalid data in the WAVE structure.
		///
		/// \return True if succeeded, else false.
		///
		////////////////////////////////////////////////////////////////
		Bool SaveToStream( std::ostream & p_Stream, const Bool p_Validate = true );

		////////////////////////////////////////////////////////////////
		/// \brief Save WAVE - PCM to file.
		///
		/// \param p_Filename Output file.
		/// \param p_Validate, If true, makes sure to save a valid WAVE file.
		///		Setting default values for invalid data in the WAVE structure.
		///
		/// \return True if succeeded, else false.
		///
		////////////////////////////////////////////////////////////////
		Bool SaveToFile( const std::string & p_Filename, const Bool p_Validate = true );

		////////////////////////////////////////////////////////////////
		/// \brief Clear the allocated audio data in the data chunk.
		///
		////////////////////////////////////////////////////////////////
		void Clear( );

		////////////////////////////////////////////////////////////////
		/// \brief Get the RIFF header.
		///
		////////////////////////////////////////////////////////////////
		RiffHeader & GetRiffHeader( );

		////////////////////////////////////////////////////////////////
		/// \brief Get the fmt chunk.
		///
		////////////////////////////////////////////////////////////////
		FmtChunk & GetFmtChunk( );

		////////////////////////////////////////////////////////////////
		/// \brief Get the data chunk
		///
		////////////////////////////////////////////////////////////////
		DataChunk & GetDataChunk( );

	private:

		RiffHeader m_RiffHeader;	///< Riff header.
		FmtChunk m_FmtChunk;		///< Fmt chunk.
		DataChunk m_DataChunk;		///< Data chunk containing the raw audio data.

	};

}

#endif